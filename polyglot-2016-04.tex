\documentclass[xcolor=svgnames]{beamer}
\usepackage{colortbl}
\usepackage{listings}
\usepackage{color}
\usepackage[T1]{fontenc}
\usepackage{textcomp}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=fullflexible,
  %basicstyle=\footnotesize,
  basicstyle={\small\ttfamily},
  numbers=left,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  language=Caml,
  morekeywords={type,val,let,in,rec,function},
  tabsize=4,
  upquote=true
}

%\usepackage{beamerthemeAmsterdam} % Non-standard. Find on Google.
\usepackage{beamerleanprogress} % Non-standard. Find on Google.
  \renewcommand{\emph}[1]{{\em #1}}
%\usecolortheme{seahorse} % lighter colours
\setbeamertemplate{navigation symbols}{} % remove silly navigation symbols
%\setbeameroption{show notes}

% Don't include backup slides in page numbers; see
% stackoverflow.com/questions/732902/ignoring-page-numbers-in-backup-slides
\newcommand{\backupbegin}{
   \newcounter{backupslides}
   \setcounter{backupslides}{\value{framenumber}}
}
\newcommand{\backupend}{
   \addtocounter{backupslides}{-\value{framenumber}}
   \addtocounter{framenumber}{\value{backupslides}}
}

\usepackage{amsmath}
  % Slanted captical Greek letters
  \let\upPi\Pi
  \let\upSigma\Sigma
  \let\Gamma\varGamma
  \let\Delta\varDelta
  \let\Theta\varTheta
  \let\Lambda\varLambda
  \let\Xi\varXi
  \let\Pi\varPi
  \let\Sigma\varSigma
  \let\Upsilon\varUpsilon
  \let\Phi\varPhi
  \let\Psi\varPsi
  \let\Omega\varOmega

\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{array,multirow}

% Specific to Beamer slides
\renewcommand{\_}{\mathunderscore}


%TODO:
\begin{document}

\title[Introduction to OCaml]{\
  Ocaml
}
\author[Anders Fugmann]{\
  \normalfont \underline{Anders Fugmann}
}
\institute{Polyglot Meetup \#8
}
\date{}

\maketitle

\section{Introduction}

\begin{frame}
  \frametitle{Overview}

  \begin{enumerate}
  \item What is Ocaml
  \item A small example
  \item Another short example
  \item Extended example
  \item Full scale
  \end{enumerate}

\end{frame}

\begin{frame}[fragile]
   \frametitle{What is OCaml}
   \begin{itemize}
   \item Functional Programming Language - But not pure!
   \item Terse
   \item Garbage collected
   \item Fast
   \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{What is OCaml}
  \begin{center}
    \Huge It's fun
  \end{center}
\end{frame}

% Brief overview
% Fac
% Let bindings, curreied functions, high order functions
% Imperative constructs
% Concurrency (No paralism) - Like stackless python and javascript
% An example of an expression parser
% Go though the steps
% Show the output
% Concurrency (No paralism) - Like stackless python and javascript
% Create a web-server
% Explain what happends
% Talk about opam
% Testing - General thoughs on why functional programming is easier to
%   test
% Create a simple test suite


% Examples can be intered in utop. We will show later how to produce a
% program


%\begin{frame}[fragile]
%  \frametitle{something}
%\end{frame}

\begin{frame}[fragile]
  \frametitle{A small example}
  A Textbook example; factorial
  \begin{lstlisting}
  # let rec fac = function
    | 0 -> 1
    | n -> n * fac (n - 1);;
  val fac : ... = <fun>

  # fac 5;;
  - : ... = 120

  \end{lstlisting}
\end{frame}

\section{Language}
\begin{frame}
  OCaml Language
  \begin{itemize}
  \item Functions are first class.
  \item Pattern matching
  \item Function currying
  \item Anonymous functions and closures
  \item Algebraic Datatypes, Tuples and records
  \item Modules and Functors
  \item ...
  \end{itemize}
\end{frame}

%% \section{Language Constructs}
%% \begin{frame}[fragile]
%%   \frametitle{Language Constructs}
%%   \begin{itemize}
%%     \item strictly evaluated
%%     \item let bindings are aliases
%%   \end{itemize}

%%   \begin{lstlisting}
%%     # let x = 5;;
%%     val x : ... = 5
%%     # let y = 6;;
%%     val y : ... = 5
%%     # x * y;;
%%     - : ... = 30
%%   \end{lstlisting}

%% \end{frame}

%% \begin{frame}[fragile]
%%   \frametitle{Functions}
%%   \begin{itemize}
%%     \item function arguments are seperated by space
%%     \item functions arguments are curried
%%     \item functions are first class
%%     \item tail call optimization
%%   \end{itemize}

%%   \begin{lstlisting}
%%     # let f x = x + 1;;
%%     var f : ... = <fun>
%%     # let g x y = x + y;;
%%     var g : ... = <fun>

%%     # apply f x = f x;;
%%     var f : ... = <fun>
%%     # apply f 5;;
%%     - : ... = 6

%%     # let h = apply f;;
%%     var g : ... = <fun>

%%     # g 2;;
%%     - : ... = 3

%%   \end{lstlisting}
%% \end{frame}

%% % \item no null pointers!

%% \begin{frame}[fragile]
%%   \frametitle{Lists}
%%   Lists are immutable.
%%   List are destructed with the '::' operator
%%   \begin{lstlisting}
%%     (* Destutter *)
%%     # let rec destutter = function
%%       | [] -> []
%%       | [ x ] -> [ x ]
%%       | x :: y :: xs when x = y -> destutter (y :: xs)
%%       | x :: y :: xs -> x :: destutter (y :: xs)
%%     val destutter : ... = <fun>

%%     # destutter [ 1; 3; 3; 5 ]
%%     - : ... = [1; 3; 5]
%%   \end{lstlisting}

%% \end{frame}

\section{A Small Calculator}

\begin{frame}[fragile]
  \frametitle{A small calculator}
  A small calculate to evaluate expressions like $3 + 4$.
  \lstinputlisting[firstline=23]{polyparser.ml}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Testing the code}
  \begin{lstlisting}
    $ ocamlfind ocamlc -package mparser -linkpkg \
      -o polyparser polyparser.ml
    $ ./polyparser 3+4
    7
    $ ./polyparser 3+4*7+1
    32
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{A small webserver}
  \lstinputlisting[firstline=32]{polyparser_http.ml}
  http://localhost:8000/3+4
\end{frame}

\begin{frame}[fragile]
  \frametitle{Compiling to javascript}
  Ocaml can be compiled to javascript and has API's for DOM
  manipulation, js events, XHR, etc.

  \begin{lstlisting}
    $ js_of_ocaml polyparser -o polyparser.js
    $ nodejs polyparser.js 3+4
    7
  \end{lstlisting}
  \pause
  But the javascript code is not really readable.
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%
%Types
%%%%%%%%%%%%%%%%%%%%%%
\section{Testing}
\begin{frame}[fragile]
  \frametitle{Type Inference}
  \begin{center}
    \Huge Testing
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Type Inference}
  \begin{enumerate}
  \item Deduces the type based on usage
  \item Validates that the program is ``sound''
  \item Not explicitly typed!
  \end{enumerate}
  \pause
  \begin{center}
    Do not make the illegal state representable!
  \end{center}
\end{frame}


\begin{frame}[fragile]
  Lets re-examine some of the previous examples:
  \begin{lstlisting}
  # let rec fac = function
    | 0 -> 1
    | n -> n * fac (n - 1);;
  val fac : int -> int = <fun>

  # fac 5;;
  - : int = 120

  # let f x y = x + y;;
  val f : int -> int -> int;;
  # 3 * "Ho";;
  Error: This expression has type string but an expression was expected of type int
  \end{lstlisting}

\end{frame}

\begin{frame}[fragile]
  Lets add types to our small example.

  \begin{lstlisting}
    type op = Add | Mul
    type expr =
      | Int of int
      | Binop of op * expr * expr

    let rec eval = function
      | Int n -> n
      | Binop (Add, a, b) -> eval a + eval b
   (* | Binop (Mul, a, b) -> eval a * eval b *)

  \end{lstlisting}
  \pause
  \begin{lstlisting}[language=make]
    $ ocamlc adtparser.ml
    File "adtparser.ml", line 6, characters 15-79:
    Warning 8: this pattern-matching is not exhaustive.
    Here is an example of a value that is not matched:
    Binop (Mul, _, _)
  \end{lstlisting}

\end{frame}

\begin{frame}[fragile]
  \frametitle{An Extended Calculator}
  Lets extend our small language with a \textit{tenary} operator and
  replacing multiplication with  \textit{less equal} operator:

  \[(5 < 4) \mathbin? (4 + 4) : (5 + 5) \to 10\]

  \pause
  But now we can create illegal expressions:

  \[4 + (5 < 4) \to *error*\]

\end{frame}

\begin{frame}[fragile]
  \frametitle{An Extended Calculator}
  \lstinputlisting[basicstyle={\footnotesize\ttfamily}]{adtparser_tenary.ml}
\end{frame}

\begin{frame}[fragile]
  \frametitle{An Extended Calculator}
  The Compiler will warn us about problems:
  \begin{lstlisting}[basicstyle={\footnotesize\ttfamily},language=make]
    File "adtparser_tenary.ml", line 11, characters 10-24:
    Warning 8: this pattern-matching is not exhaustive.
    Here is an example of a value that is not matched:
    (Bool _, _)
    File "adtparser_tenary.ml", line 14, characters 10-24:
    Warning 8: this pattern-matching is not exhaustive.
    Here is an example of a value that is not matched:
    (Bool _, _)
    File "adtparser_tenary.ml", line 17, characters 10-16:
    Warning 8: this pattern-matching is not exhaustive.
    Here is an example of a value that is not matched:
    Int _
  \end{lstlisting}

\end{frame}

\begin{frame}[fragile]
  \frametitle{A Safe calculator}
  Using Generalized Algebraic Data Type we can express the restrictions.

  \lstinputlisting[basicstyle={\footnotesize\ttfamily}]{gadtparser.ml}
\end{frame}

\begin{frame}[fragile]
  \frametitle{A Safe calculator}
  The compiler will not accept illegal expressions:

  \[4 + (5 < 4)\]

  \begin{lstlisting}[language=,morekeywords={Lt,bool,int}]
    # Binop (Add, Int 4, Binop (Lt, Int 5, Int 4));;
    Error: This expression has type bool binop
    but an expression was expected of type int binop
    Type bool is not compatible with type int
  \end{lstlisting}

\end{frame}

\begin{frame}[fragile]
  \frametitle{AVL trees}
  Defining a balanced tree which the compiler will validate that its
  always balanced.

  \begin{lstlisting}
    (* Peano numbers: succ (succ (succ z)): 3 *)
    type z
    type succ
    type 'a s = succ * 'a

    type _ node =
      | LNode: ('a s node * 'a node   * int) -> 'a s s node
      | RNode: ('a node   * 'a s node * int) -> 'a s s node
      | BNode: ('a node   * 'a node   * int) -> 'a s node
      | Empty: z node
  \end{lstlisting}

\end{frame}

\section{Try Ocaml}
\begin{frame}[fragile]
  \frametitle{Using Ocaml}
  To try out ocaml go to https://try.ocamlpro.com/, or install it locally:
  \begin{lstlisting}
    $ brew install opam
    $ opam switch 4.02.3
    $ opam install utop
    $ utop
  \end{lstlisting}
\end{frame}

\section{Large Scale}
\begin{frame}[fragile]
  \begin{itemize}
  \item Using Ocaml for more that 5 years at issuu
  \item Approx 50K lines of OCaml code in production
  \item Single thread parses ~2K Deep json structure and create
    graphite statistics
  \item Created DSL for user behavioural analysis, analysing more than
    7 Billion events (one month) in minutes.
  \end{itemize}
\end{frame}

\section{}
\begin{frame}[fragile]
  \begin{center}
    \LARGE Questions
  \end{center}
\end{frame}

\end{document}


%% Need to create a webserver, using the API to actually produce
%% something

%% Mention that ocaml cannot branch on type runtime. Therefore we
%% need to tag our variables - like units.

%% Show opam - That there exists a community
%% Second section is about not representing the illegal state.

%% Redo first section
%% - Use current example to show all places where the illegal state is
%% representable, and fix it.
